<!DOCTYPE html>
<html>
<head>
  <% include ../partials/header.ejs %>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"></head>
<script src="/socket.io/socket.io.js"></script>
    <script src="libs/three.min.js"></script>
    <script src="libs/OBJLoader.js"></script>
    <script src="libs/display.js"></script>
<script>
//var srch=window.location.search.replace("?", "");
//var sets=srch.split("&");
  //for (var s=0; s<sets.length; s++){
    //var parts=sets[s].split("=");
    //if(parts[0]=="roomId"){myRoomId=parts[1];}
  //}
var myRoomId=181;
var myUserId=<%= rows[0].id %>;
var socket = io.connect();
var myImage;
  
console.log('client.ejs myRoomId='+myRoomId);

socket.emit("subscribeClient", { roomId: myRoomId, userId: myUserId, clientMs:new Date().getTime()});

socket.on('clientState', function(data) {
  if(runnable){
    var nowMs=new Date().getTime();
    //console.log("client.ejs clientState");
    //console.log(data);
    var userIds=[];
    for (var b=0; b<boats.length; b++){
      userIds.push(boats[b].userId);
    }    
    var user=data;
    if(userIds.indexOf(user.userId)==-1){
      console.log("client.ejs roomState create "+boats.length+" "+runnable);
      user.num=boats.length;
      user.updated=nowMs;
      boats.push(newBoat(user));
      playSoundName("go");
    }
    else{
      if(user.userId != myUserId){
        var ord=userIds.indexOf(user.userId);
        if(boats[ord].loaded){
          
          boats[ord].updated=nowMs;
          boats[ord].iRads=user.iRads;
          boats[ord].control=user.control;
          boats[ord].pitch=user.pitch;
          boats[ord].speed=user.speed;
          boats[ord].x=user.x;
          boats[ord].z=user.z;
          boats[ord].missileX=user.missileX;
          boats[ord].missileY=user.missileY;
          boats[ord].missileZ=user.missileZ;
          boats[ord].missileSpeed=user.missileSpeed;
          boats[ord].missileFired=user.missileFired;
          boats[ord].detonation=user.detonation;
        }
      }
    }
  }
});


  
  socket.on('haveSeeds', function(data) {
    if(mapReceived==false){
      console.log("client.ejs haveSeeds "+data.seeds);
      mySeeds=JSON.parse(data.seeds);
      mapReceived=true;

      canvas = document.createElement('canvas');
      canvas.width = useSize;
      canvas.height = useSize;
      var ctx = canvas.getContext('2d');
      console.log(mySeeds);
      islandFromSeeds(ctx,useSize, mySeeds);

      var pixel = canvas.toDataURL();
      console.log(typeof pixel);
      myImage = new Image();
      document.getElementById('hideMe').appendChild(myImage);
      //createGeometryFromMap(ctx);
      myImage.onload=function(){
        console.log('myImage onload');
        var ctx = canvas.getContext('2d');
        ctx.drawImage(myImage, 0, 0);
        initScene();
      }
      myImage.src = pixel;

    }
  });

var mySeeds=[.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5];
var saveMap="";
var mapReceived=false;
var sendTime=0;
var tickTimeout;
function emitTick(){
  window.clearTimeout(tickTimeout);
  //console.log('emitTick()');
  var dataObj={
    roomId:+myRoomId,
    userId:myUserId,
    control:boats[0].control,
    iRads:boats[0].iRads,
    loaded:false,
    local:false,
    pitch:boats[0].pitch,
    speed:boats[0].speed,
    throttle:boats[0].throttle,
    x:boats[0].x,
    z:boats[0].z,
    missileX:boats[0].missileX,
    missileY:boats[0].missileY,
    missileZ:boats[0].missileZ,
    missileSpeed:boats[0].missileSpeed,
    missileIrads:boats[0].missileIrads,
    missileFired:boats[0].missileFired,
    detonation:boats[0].detonation
  }  
  //console.log(dataObj);
  socket.emit("clientState", dataObj);  
  tickTimeout=window.setTimeout("emitTick()", 100);

}


// begin copied from terrain2
var pi=Math.PI;
var useSize=512;
var dist=useSize/2;
var heightOffset=12;
var heightMap=[];
var mode="player";
var renderer;
var scene;
var camera;
var control;
var minVal=1000;
var maxVal=0;
var boats=[];
var camDist=32;
var canvas;
var myImage;
var runnable=false;
function tick(){
  var nowMs=new Date().getTime();
  boats[0].updated=nowMs;
  var culls=[];
  for (var b=0; b<boats.length; b++){
    if(boats[b].loaded){
      var deltaMs=nowMs-boats[b].updated;
      if(deltaMs>10000){
        culls.unshift(b);
      }
    }
  }
  for (var c=0; c<culls.length; c++){
    var gone=boats.splice(culls[c],1)[0];
    scene.remove(gone.carYaw);
    scene.remove(gone.missileModel);
  }
  // once to calc, 
  for (var b=0; b<boats.length; b++){
    if(boats[b].loaded){
      runnable=true;
      var half=useSize/2;

      // loop physics cycles?
      if(boats[b].spinout>0){
        boats[b].spinout-=.01;
        boats[b].pitch=boats[b].iRads*(1-boats[b].spinout)+10*boats[b].spinout;
        boats[b].speed=maxSpeed*2*boats[b].spinout;
      }
      else{
        boats[b].pitch+=boats[b].control;

        var inX=Math.cos(boats[b].iRads)*boats[b].speed;
        var inY=-Math.sin(boats[b].iRads)*boats[b].speed;
        var thX=Math.cos(boats[b].pitch)*boats[b].throttle*carSize*.05;
        var thY=-Math.sin(boats[b].pitch)*boats[b].throttle*carSize*.05;
        var sumX=inX+thX;
        var sumY=inY+thY;
        boats[b].iRads=xyxyToRads(0,0,sumX,sumY);
        boats[b].speed=Math.sqrt(sumX*sumX+sumY*sumY);
        var drag=1*carSize*(boats[b].speed/10);
        if(boats[b].y==0){drag=drag/2;}
        boats[b].speed-=drag;
      }
      boats[b].x+=xRadiansScale(boats[b].iRads, boats[b].speed);
      boats[b].z-=yRadiansScale(boats[b].iRads, boats[b].speed);
      if(boats[b].x>half){boats[b].x=half;}
      if(boats[b].x<0-half){boats[b].x=0-half;}
      if(boats[b].z>half){boats[b].z=half;}
      if(boats[b].z<0-half){boats[b].z=0-half;}

      boats[b].y=worldAlt(boats[b].x, boats[b].z);


      boats[b].frontX=boats[b].x+xRadiansScale(boats[b].pitch, carSize*6);
      boats[b].frontZ=boats[b].z-yRadiansScale(boats[b].pitch, carSize*6);
      boats[b].frontY=worldAlt(boats[b].frontX, boats[b].frontZ);

      boats[b].backX=boats[b].x+xRadiansScale(boats[b].pitch-pi, carSize*6);
      boats[b].backZ=boats[b].z-yRadiansScale(boats[b].pitch-pi, carSize*6);
      boats[b].backY=worldAlt(boats[b].backX, boats[b].backZ);
      boats[b].leftX=boats[b].x+xRadiansScale(boats[b].pitch+pi/2, carSize*3);
      boats[b].leftZ=boats[b].z-yRadiansScale(boats[b].pitch+pi/2, carSize*3);
      boats[b].leftY=worldAlt(boats[b].leftX, boats[b].leftZ);
      boats[b].rightX=boats[b].x+xRadiansScale(boats[b].pitch-pi/2, carSize*3);
      boats[b].rightZ=boats[b].z-yRadiansScale(boats[b].pitch-pi/2, carSize*3);
      boats[b].rightY=worldAlt(boats[b].rightX, boats[b].rightZ);
      if(boats[b].missileFired==false){
        boats[b].missileX=boats[b].frontX;
        boats[b].missileZ=boats[b].frontZ;
        boats[b].missileY=boats[b].frontY+carSize;    
        boats[b].missileIrads=boats[b].pitch;    
      }
      else{// missile is fired
        if(boats[b].detonation>0){//detonating
          boats[b].detonation-=.02;
          if(boats[b].detonation<=0){// completed detonation, reset
            shouldDetonate=false;
            boats[b].missileFired=false;
            boats[b].detonation=0;
            boats[b].missileX=boats[b].frontX;
            boats[b].missileZ=boats[b].frontZ;
            boats[b].missileY=boats[b].frontY+1;    
            boats[b].missileIrads=boats[b].pitch;
            boats[b].missileModel.scale.set(carSize*2,carSize*2,carSize*2);
            boats[b].missileModel.material.opacity=1;

          }
          else{//display detonating
            var s=4*carSize*(1+6*(.5+(1-boats[b].detonation)));
            var o=(boats[b].detonation);
            boats[b].missileModel.scale.set(s,s,s);
            boats[b].missileModel.material.opacity=o;
          } 
        }
        else{// fire and hit test
          var triggered=false;
          if(shouldDetonate){triggered=true;}
          if(boats[b].missileX<(0-useSize/1.95)){triggered=true;}
          if(boats[b].missileZ<(0-useSize/1.95)){triggered=true;}
          if(boats[b].missileX>(useSize/1.95)){triggered=true;}
          if(boats[b].missileZ>(useSize/1.95)){triggered=true;}

          for (var t=0; t<boats.length; t++){
            if(t !=b){
              var dx=boats[t].x-boats[b].missileX;
              var dz=boats[t].z-boats[b].missileZ;
              var dist=Math.sqrt(dx*dx+dz*dz);
              if(dist<carSize*10){
                triggered=true;
              }
            }
          }

          if(triggered){
            shouldDetonate=false;
            boats[b].detonation=1
            for (var t=0; t<boats.length; t++){
              if(t !=b){
                var dx=boats[t].x-boats[b].missileX;
                var dz=boats[t].z-boats[b].missileZ;
                var dist=Math.sqrt(dx*dx+dz*dz);
                if(dist<carSize*30){
                  var rads=xyxyToRads(boats[b].missileX,boats[b].missileZ,boats[t].x,boats[t].z);
                  boats[t].speed=maxSpeed*2;
                  boats[t].spinout=1;
                  boats[t].iRads=rads;
                }
              }
            }
          }
          else{//carry on.
            boats[b].missileX+=xRadiansScale(boats[b].missileIrads, boats[b].missileSpeed);
            boats[b].missileZ-=yRadiansScale(boats[b].missileIrads, boats[b].missileSpeed);
            boats[b].missileY=worldAlt(boats[b].missileX, boats[b].missileZ)+1;
            boats[b].missileModel.scale.set(carSize*4,carSize*4,carSize*4);
            boats[b].missileModel.material.opacity=1;
          }
        }
      }
    }
  }
        dbug(Math.floor(boats[0].speed*100));

  for (var b=0; b<boats.length; b++){
    if(boats[b].loaded){
      boats[b].missileModel.position.x=boats[b].missileX;
      boats[b].missileModel.position.y=boats[b].missileY;
      boats[b].missileModel.position.z=boats[b].missileZ;
      boats[b].carYaw.position.x=boats[b].x;
      boats[b].carYaw.position.y=boats[b].y;
      boats[b].carYaw.position.z=boats[b].z;
      boats[b].carYaw.rotation.y=boats[b].pitch;
      boats[b].carRoll.rotation.x=boats[b].leftY/3-boats[b].rightY/3;
      boats[b].carPitch.rotation.z=boats[b].frontY/3-boats[b].backY/3;
      boats[b].model.rotation.x=boats[b].leftY/3-boats[b].rightY/3;
    }
  }
  if(mode != "server"){
    var camVec=boats[0].pitch-pi;
    camera.position.x = boats[0].x+xRadiansScale(camVec,camDist);
    camera.position.y = boats[0].y+camDist/2-4;
    camera.position.z = boats[0].z-yRadiansScale(camVec,camDist);
    camera.lookAt(boats[0].carYaw.position);
  }

}


function init(){
  //initScene();
}
var controls;
function initScene() {
  console.log('initScene');
  // create a scene, that will hold all our elements such as objects, cameras and lights.
  scene = new THREE.Scene();
  // create a camera, which defines where we're looking at.
  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
  // create a render, sets the background color and the size
  renderer = new THREE.WebGLRenderer();
  renderer.setClearColor(0x000000, 1.0);
  renderer.setSize(window.innerWidth, window.innerHeight);
  // add light
  var light = new THREE.DirectionalLight();
  light.position.set(1200, 1200, 1200);
  scene.add(light);
  var alight = new THREE.AmbientLight( 0x404040 ); // soft white light
  scene.add( alight );
  // position and point the camera to the center of the scene
  camera.position.x = 0;
  camera.position.y = 640;
  camera.position.z = 0;
  camera.lookAt(scene.position);
        camera.rotation.z=pi/2;

  // add the output of the renderer to the html element
  document.body.appendChild(renderer.domElement);
  renderer.domElement.style.position="absolute";
  boats.push(newBoat({num:0, userId:myUserId, loaded:false, local:true, x:0, z:0, throttle:0, speed:0, pitch:0, iRads:0, control:0, missileX:0,missileY:0,missileZ:0,missileSpeed:maxSpeed*3,missileIrads:0, missileFired:false, detonation:0}));

  var ctx=canvas.getContext('2d');
  createGeometryFromMap(ctx);

  controls = document.createElement('canvas');
  document.body.appendChild(controls); // adds the canvas to the body element

controls.addEventListener('touchstart', touchStart, false);
controls.addEventListener('touchmove', touchMove, false);
controls.addEventListener('touchend', touchEnd, false);

  controls.width=window.innerWidth;
  controls.height=window.innerHeight;

  //controls.style.backgroundColor="rgba(255,0,0,.5)";
  controls.style.margin=0;
  controls.style.position="absolute";
  // call the render function
  drawUi();
  render();
      playSoundName("go");

        document.getElementById('hideMe').style.display="none";

  document.onkeydown = downKey;
  document.onkeyup = upKey;
  tickTimeout=window.setTimeout("emitTick()", 100);

  //window.setTimeout("window.location.reload()",60000);
}
var soundInited=false;
function updateProgress(){}
function touchStart(e){
  e.preventDefault ();
  if(soundInited==false){
    playSoundName("click");
    soundInited=true;
  }
  console.log(e.touches);
  processTouches(e.touches);
}
function touchMove(e){
  e.preventDefault ();
  console.log(e.touches);
  processTouches(e.touches);
}
function touchEnd(e){
  e.preventDefault ();
  console.log(e.touches);
  processTouches(e.touches);
}
function processTouches(touches){
  var nextObj=JSON.parse(JSON.stringify(controlsObj));
  var prevObj=JSON.parse(JSON.stringify(controlsObj));
  var keys=Object.keys(controlsObj);

  for (var k=0; k<keys.length; k++){
    var key=keys[k];
    nextObj[key].down=false;
  }
  for(var t=0; t<touches.length; t++){
    for (var k=0; k<keys.length; k++){
      var key=keys[k];
      var control=controlsObj[key];
      if((touches[t].screenX>control.l)&&(touches[t].screenX<control.r)&&(touches[t].screenY>control.t)&&(touches[t].screenY<control.b)){
        nextObj[key].down=true;
      }
    }
  }
  for (var k=0; k<keys.length; k++){
    var key=keys[k];
    if((prevObj[key].down==true)&&(nextObj[key].down==false)){setControl(key, false);}
    if((prevObj[key].down==false)&&(nextObj[key].down==true)){setControl(key, true);}
  }
  
}

var controlsObj={
  "minus":{
     keyCode:189,
     down:false,
     x:-8, y:0, w:4,h:4,
     t:0, r:0, b:0, l:0,
     path:[[1,1.75],[3,1.75],[3,2.25],[1,2.25],[1,1.75]]
  },
  "plus":{
     keyCode:187,
     down:false,
     x:-4, y:0, w:4,h:4,
     t:0, r:0, b:0, l:0,
     path:[[1.75,1.75],[1.75,1],[2.25,1],[2.25,1.75],[3,1.75],[3,2.25],[2.25,2.25],[2.25,3],[1.75,3],[1.75,2.25],[1,2.25],[1,1.75],[1.75,1.75]]
  },
  "start":{
     keyCode:'38',
     down:false,
     x:-8, y:-8, w:4,h:4,
     t:0, r:0, b:0, l:0,
     path:[[2,1],[3,3],[1,3],[2,1]]
  },
  "stop":{
     keyCode:'40',
     down:false,
     x:-8, y:-4, w:4,h:4,
     t:0, r:0, b:0, l:0,
     path:[[1,1],[3,1],[2,3],[1,1]]
  },
  "left":{
     keyCode:'37',
     down:false,
     x:-12, y:-4, w:4,h:4,
     t:0, r:0, b:0, l:0,
     path:[[1,2],[3,1],[3,3],[1,2]]
  },
  "right":{
     keyCode:'39',
     down:false,
     x:-4, y:-4, w:4,h:4,
     t:0, r:0, b:0, l:0,
     path:[[1,1],[3,2],[1,3],[1,1]]
  },
  "fire":{
     keyCode:'32',
     down:false,
     x:0, y:-4, w:8,h:4,
     t:0, r:0, b:0, l:0,
     path:[[1,1],[7,1],[7,3],[1,3],[1,1]]
  }
}
var ww;
var wh;
var shouldDetonate=false;
function setControl(key,value){
    var changed=true;
    if(controlsObj[key].down==value){changed=false;}
    controlsObj[key].down=value;
    if(changed){
      handleToggle(key, value);
    }
  drawUi();
}
function handleToggle(key,value){
  if(key=="plus"){
    if((camDist>8)&&(value==true)){camDist*=.5;}
  }
  if(key=="minus"){
    if((camDist<512)&&(value==true)){camDist*=2;}
  }
  if(key=="start"){
    if(value==true){
      boats[0].throttle+=.5;
      if(boats[0].throttle>1){boats[0].throttle=1;}
      //boats[0].speed=boats[0].throttle;
    }
  }
  if(key=="stop"){
    if(value==true){
      boats[0].throttle-=.5;
      if(boats[0].throttle<-1){boats[0].throttle=-1;}
      //boats[0].speed=boats[0].throttle;
    }
  }
  if(key=="left"){
    if(value==true){boats[0].control=.03;}
    else{boats[0].control=0;}
  }
  if(key=="right"){
    if(value==true){boats[0].control=-.03;}
    else{boats[0].control=0;}
  }
  if(key=="fire"){
    if(value==true){
      if(boats[0].missileFired==false){
        boats[0].missileFired=true;
      }
      else{
        shouldDetonate=true;
      }
    }
  }
}
function drawUi(){
  ww=window.innerWidth;
  wh=window.innerHeight;
  var cellsAcross=24;
  var grid=ww/cellsAcross;
  if(ww>wh){grid=wh/cellsAcross;}

  controls.width=ww;
  var ctx=controls.getContext('2d');
  ctx.strokeStyle="white";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(ww-2*grid, grid*6);
  ctx.lineTo(ww-2*grid, grid*14);
  ctx.moveTo(ww-3*grid, grid*10);
  ctx.lineTo(ww-1*grid, grid*10);
  ctx.stroke();
  var yCenter=grid*10-boats[0].throttle*grid*4;
  //dbug(boats[0].throttle);

  ctx.beginPath();
  ctx.arc(ww-2*grid,yCenter,grid,0,pi*2,true);
  ctx.stroke();
  for (var r=0; r<2; r+=2/3){
     ctx.beginPath();
     var x=ww-2*grid+Math.cos(r*pi)*grid;
     var y=yCenter+Math.sin(r*pi)*grid;
     ctx.arc(x,y,grid,r*pi-pi*1/3+pi, r*pi+pi*1/3+pi, false);
     ctx.stroke();
   }
  
  var keys=Object.keys(controlsObj);
  for (var k=0; k<keys.length; k++){
    var key=keys[k];
    var control=controlsObj[key];

    controlsObj[key].t=control.y*grid;
    if(control.y<0){controlsObj[key].t+=wh;}
    controlsObj[key].b=controlsObj[key].t+control.h*grid;
    controlsObj[key].l=control.x*grid;
    if(control.x<0){controlsObj[key].l+=ww;}
    controlsObj[key].r=controlsObj[key].l+control.w*grid;
    ctx.strokeRect(controlsObj[key].l,controlsObj[key].t,+control.w*grid,+control.h*grid);
    ctx.beginPath();
    ctx.moveTo(controlsObj[key].l+control.path[0][0]*grid,controlsObj[key].t+control.path[0][1]*grid);
    for (var p=1; p<control.path.length; p++){
      ctx.lineTo(controlsObj[key].l+control.path[p][0]*grid,controlsObj[key].t+control.path[p][1]*grid);
    }
    ctx.stroke();
    if(control.down){  ctx.fillStyle="yellow";}
    else{  ctx.fillStyle="blue";}

    ctx.fill();
  }
}

function downKey(e) {
  e.preventDefault();
  console.log(e.keyCode);
  var keys=Object.keys(controlsObj);
  for (var k=0; k<keys.length; k++){
    var key=keys[k];
    var control=controlsObj[key];
    if(e.keyCode==control.keyCode){
      setControl(key,true);
    }
  }
}
function upKey(e) {
  e.preventDefault();
  console.log('up '+e.keyCode);
  var keys=Object.keys(controlsObj);
  for (var k=0; k<keys.length; k++){
    var key=keys[k];
    var control=controlsObj[key];
    if(e.keyCode==control.keyCode){
      setControl(key,false);
    }
  }
} 

function render() {
  tick();
  renderer.render(scene, camera);
  requestAnimationFrame(render);
}
function playSoundNum(num, ends){
  var sound = new Sound(fxContext, fxBuffer.getSoundByIndex(num), ends);
  sound.play();
}
function playSoundName(name){
  playSoundNum(soundNumByName[name], false);
}

function setupSounds(path, soundNames){
  var sounds=[];
  for(var n=0; n<soundNames.length; n++){
    var clean=soundNames[n].replace(".mp3", "");
    soundNumByName[clean]=n;
    sounds.push(path+soundNames[n]);
  }
  fxContext = new (window.AudioContext || window.webkitAudioContext)();

  fxBuffer = new Buffer(fxContext, sounds);
  fxBuffer.loadAll();
}

class Buffer {
  constructor(context, urls) {  
    this.context = context;
    this.urls = urls;
    this.buffer = [];
  }

  loadSound(url, index) {
    let request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    let thisBuffer = this;
    request.onload = function() {
      thisBuffer.context.decodeAudioData(request.response, function(buffer) {
        thisBuffer.buffer[index] = buffer;
        updateProgress(thisBuffer.urls.length);
        if(index == thisBuffer.urls.length-1) {
          thisBuffer.loaded();
        }       
      });
    };
    request.send();
  };

  loadAll() {
    this.urls.forEach((url, index) => {
      this.loadSound(url, index);
    })
  }

  loaded() {
    // what happens when all the files are loaded
  }

  getSoundByIndex(index) {
    return this.buffer[index];
  }

}

class Sound {

  constructor(context, buffer, ends) {
    this.ends = ends;
    this.context = context;
    this.buffer = buffer;
  }

  init() {
    this.gainNode = this.context.createGain();
    this.source = this.context.createBufferSource();

    this.source.buffer = this.buffer;
    this.source.connect(this.gainNode);
    this.gainNode.connect(this.context.destination);
  }

  play() {
    this.init();
    this.source.start(this.context.currentTime);
    console.log('uh '+this.buffer.duration);

  }  

  stop() {
    this.gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.5);
    this.source.stop(this.context.currentTime + 0.5);
  }

}
var fxContext;
var fxBuffer;
var soundNumByName={}
  
setupSounds("sounds/", ["go.mp3", "click.mp3", "bell.mp3"]);  

</script>
<body onload="init()">

<!--<% include ../partials/nav.ejs %>-->

<div class="container">
  <div id="hideMe">
    <h2>User Created <%= rows[0].name %> </h2>
    <h3>Initializing 3d...</h3>
<!--
    <ul>
      <% rows.forEach(function(r) { %>
        <li><%= r.id %> - <%= JSON.stringify(r) %></li>
      <% }); %>
    </ul>
-->    <div id="network"></div>
  </div>
</div>
    <div id="debug" style="position:absolute; display:none; background-color:black; color:white; z-index:100;">DEBUG</div>

</body>
</html>
